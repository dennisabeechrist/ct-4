<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Maze Protocol: Ultimate CTF</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Share+Tech+Mono&display=swap');
    html, body { height: 100%; margin: 0; }
    body {
      background: #030b13; color: #00ff99;
      font-family: 'Share Tech Mono', monospace;
      display: flex; flex-direction: column; align-items: center; min-height: 100vh;
    }
    h1 { margin-top: 1.1rem; margin-bottom: 0.6rem; font-size: 2.2rem;
      text-shadow: 0 0 8px #5cfff6,0 0 18px #22ffb6;}
    #maze {
      margin:1.2em 0 1.5em 0;
      display: grid;
      grid-template-columns: repeat(10,32px);
      grid-template-rows: repeat(10,32px);
      gap:4px;
    }
    .tile {
      width:32px; height:32px;
      border-radius:6px;
      background:#0a1521; border:1.5px solid #1eaf7f20;
      display:flex; align-items:center; justify-content:center;
      font-size:1.17em;
      transition: background .2s, box-shadow .18s;
      user-select:none;
    }
    .tile.wall { background:#232842; border:2px solid #3fffa733; }
    .tile.visited { background:#0e3627; }
    .tile.player { background:#00ffb4; box-shadow:0 0 16px #00ff99cc; color:#193025;}
    .tile.trap { background:#a1162a; color:#fff; box-shadow:0 0 9px #ff220044;}
    .tile.fakeflag { background:#11ceba; color:#161e12; }
    .tile.flag { background:#b7ff37; color:#415704; font-weight:bold; box-shadow:0 0 14px #e8ff43;}
    .tile.teleport { background:#9933ff; color:#fff;}
    .tile.mystery { background:#386cf1; color:#f1ecfc;}
    .tile.oneway { background:repeating-linear-gradient(45deg, #556, #cca 5px, #556 10px);}
    #overlay {
      position: fixed; top: 0; left: 0;
      width: 100vw; height: 100vh;
      z-index: 10; background: rgba(15,22,44,0.86);
      display: none; flex-direction: column; align-items: center; justify-content: center;
      color: #ececec; font-family: monospace; font-size: 1.5em;
    }
    .stats { margin-top: 0.2em; margin-bottom:0.8em; font-size:1.1em;}
    #minimap { margin:0.9em 0; font-size:.97em; display:none;}
    button { margin:.28em .22em; font-size:.97em; background:#002911; border:1.5px solid #00faa7; color:#fff; border-radius:5px;}
    button:focus { outline:2.5px solid #fff;}
    #message {font-size:1.18em; margin:.4em 0 .7em 0; min-height:1.9em; color:#39ffa2;}
    .cb { filter: grayscale(1) brightness(1.3) contrast(2);}
    .high { filter: contrast(2.8) saturate(1.8);}
    .min { filter: grayscale(1) brightness(1.3);}
  </style>
</head>
<body>
<h1>Maze Protocol - Ultimate CTF</h1>
<div id="message"></div>
<div style="font-size:1em;max-width:510px;text-align:center;line-height:1.2;">
  <b>Navigate using Arrow keys or WASD.</b><br>
  <small>Step on üü£ (teleport) and ‚ùì (mystery);‚Äîfind the real <span style="color:#c9ff37">üèÅ flag</span>!<br>
  <b>Press:</b> H = High-Contrast,  C = Colorblind,  N = Minimalist,  M = Toggle Minimap.<br>
  R = Reset Maze. S = Show Streak/Scoreboard. Q = Dismiss overlay.
  </small>
</div>
<div class="stats" id="stats"></div>
<div id="maze"></div>
<div style="margin-top:1em;">
  <button onclick="resetMaze()">Reset (R)</button>
  <button onclick="showOverlay()">Stats (S)</button>
  <button onclick="toggleMinimap()">Minimap (M)</button>
</div>
<div id="minimap"></div>
<div id="overlay"></div>
<script>
const SIZE=10, WALL='#', PATH='.';
const mazeDiv = document.getElementById("maze");
const messageEl = document.getElementById("message");
const statsEl = document.getElementById("stats");
const overlay = document.getElementById("overlay");
const minimap = document.getElementById("minimap");
let grid, player, flag, moves=0, deadEnds=0, streak=0, bestMoves=null, visited, fakeFlags, traps, teleports, mysteries, oneWays, replayHistory=[];
let mode = '';
function rng(n){return Math.floor(Math.random()*n);}
function shuffle(a){for(let i=a.length-1;i>0;i--){let j=rng(i+1); [a[i],a[j]]=[a[j],a[i]];}}
function resetMaze(){
  // Maze generation by randomized DFS
  grid=[...Array(SIZE)].map(()=>Array(SIZE).fill(WALL));
  visited=[...Array(SIZE)].map(()=>Array(SIZE).fill(false));
  let stack=[[0,0]], px=0, py=0; grid[0][0]=PATH;
  while(stack.length){
    let [x,y]=stack[stack.length-1], dirs=[];
    for(let [dx,dy] of [[0,2],[0,-2],[2,0],[-2,0]]){
      let nx=x+dx,ny=y+dy;
      if(nx>=0&&ny>=0&&nx<SIZE&&ny<SIZE&&grid[ny][nx]===WALL)dirs.push([nx,ny]);
    }
    if(dirs.length){
      let [nx,ny]=dirs[rng(dirs.length)];
      grid[(ny+y)/2][(nx+x)/2]=PATH; grid[ny][nx]=PATH; stack.push([nx,ny]);
    }
    else stack.pop();
  }
  // Place player, flag, traps, fake flags, teleport, mystery, oneways
  player={x:0,y:0}; moves=0;replayHistory=[];
  let empties=[];for(let y=0;y<SIZE;y++)for(let x=0;x<SIZE;x++)if(grid[y][x]===PATH)empties.push([x,y]);
  shuffle(empties);
  flag = empties.pop();
  fakeFlags=[],traps=[],teleports=[],mysteries=[],oneWays=[];
  for(let i=0;i<3;i++) fakeFlags.push(empties.pop()||[0,0]);
  for(let i=0;i<6;i++) traps.push(empties.pop()||[0,0]);
  teleports.push(empties.pop()||[0,0]);
  mysteries.push(empties.pop()||[0,0]);
  for(let i=0;i<3;i++) oneWays.push(empties.pop()||[0,0]);
  deadEnds=0;
  stats();
  draw();
  message("Maze reset. Navigate to the üèÅ flag!");
}
function tileType(x,y){
  if(x===player.x&&y===player.y)return "player";
  if(x===flag[0]&&y===flag[1])return "flag";
  for(let [fx,fy]of fakeFlags)if(x===fx&&y===fy)return "fakeflag";
  for(let [tx,ty]of traps)if(x===tx&&y===ty)return "trap";
  for(let [tx,ty]of teleports)if(x===tx&&y===ty)return "teleport";
  for(let [mx,my]of mysteries)if(x===mx&&y===my)return "mystery";
  for(let [ox,oy]of oneWays)if(x===ox&&y===oy)return "oneway";
  return grid[y][x]===WALL ? "wall" : visited[y][x] ? "visited" : "";
}
function movePlayer(dx,dy){
  let nx=player.x+dx,ny=player.y+dy;
  if(nx<0||ny<0||nx>=SIZE||ny>=SIZE)return;
  if(grid[ny][nx]===WALL){message("üöß Wall!");return;}
  // Oneway: Only allow movement from matching sides
  for(const [ox,oy] of oneWays){
    if(nx===ox&&ny===oy){
      if(dx===-1){message("‚õî One-way right‚Üíleft!");return;}
    }
  }
  player={x:nx,y:ny};moves++;visited[ny][nx]=true;replayHistory.push([nx,ny]);
  let t=tileType(nx,ny);
  if(t==="trap"){message("üî• Trap! Sent to start.");player={x:0,y:0};moves+=2;}
  if(t==="teleport"){message("üü£ Teleport!");let e=[];for(let y=0;y<SIZE;y++)for(let x=0;x<SIZE;x++)if(grid[y][x]===PATH&&!(x==nx&&y==ny))e.push([x,y]);let [tx,ty]=e[rng(e.length)];player={x:tx,y:ty};}
  if(t==="mystery"){let k=rng(3);if(k===0){message("üîç Bonus: Revealed dead ends!");drawMinimap(true);return;}else if(k===1){message("üí• Dead end! Sent to start.");player={x:0,y:0};}else{message("üíé +1 moves bonus!");moves--;}}
  if(t==="fakeflag"){message("‚ùóÔ∏èFake flag! Try again.");}
  if(nx===flag[0]&&ny===flag[1]){
    message("üèÅ <b>You found the flag!</b> <br>flag{ultimate_maze_ctf} <br>Moves: "+moves);
    streak++; if(!bestMoves||moves<bestMoves)bestMoves=moves;
    setTimeout(()=>{if(confirm("Play again?"))resetMaze();}, 1200); return;
  }
  draw();
  stats();
}
function draw(){
  mazeDiv.innerHTML="";
  for(let y=0;y<SIZE;y++)for(let x=0;x<SIZE;x++){
    let d=document.createElement("div"); d.className="tile "+tileType(x,y);
    d.tabIndex = 0;
    d.setAttribute("aria-label",`Row ${y+1} Col ${x+1} ${tileType(x,y)}`);
    let emoji="";
    let t=tileType(x,y);
    if(t==="player")emoji="ü§ñ"; else if(t==="flag")emoji="üèÅ"; else if(t==="fakeflag")emoji="üö©";
    else if(t==="trap")emoji="üíÄ"; else if(t==="teleport")emoji="üü£";
    else if(t==="mystery")emoji="‚ùì"; else if(t==="oneway")emoji="‚Üí";
    d.innerHTML=emoji;
    mazeDiv.appendChild(d);
  }
}
function message(txt){messageEl.innerHTML=txt;}
function stats(){statsEl.innerHTML=`Moves: ${moves} | Streak: ${streak} | Best: ${bestMoves??'-'}`;}
function toggleMinimap(force){
  let out='<b>Minimap (Walls#)</b><br><pre>';
  for(let y=0;y<SIZE;y++){
    for(let x=0;x<SIZE;x++){
      let t=tileType(x,y);
      if(grid[y][x]===WALL)out+="#";
      else if(t==="player")out+="P";
      else if(t==="flag")out+="F";
      else if(t==="trap")out+="X";
      else if(t==="fakeflag")out+="!";
      else if(t==="teleport")out+="T";
      else if(t==="mystery")out+="?";
      else out+=grid[y][x]==PATH?'.':' ';
    }out+="\n";
  }
  out+="</pre>";
  minimap.innerHTML=out;
  minimap.style.display=(minimap.style.display=='block'||force)?'none':'block';
}
function drawMinimap(once){ minimap.style.display='block'; toggleMinimap(true); setTimeout(()=>minimap.style.display='none',2600);}
function showOverlay(){
  overlay.style.display='flex';
  overlay.innerHTML=`<b>CTF MAZE STATS</b><br>
  Moves so far: ${moves}<br>
  Streak: ${streak}<br>
  Best Run: ${bestMoves??'-'} moves<br>
  <br>
  [Q] to dismiss overlay.`;
}
function toggleMode(m){
  mode=m; mazeDiv.classList.remove("cb","high","min");
  if(m==="cb")mazeDiv.classList.add("cb");
  if(m==="high")mazeDiv.classList.add("high");
  if(m==="min")mazeDiv.classList.add("min");
}
window.addEventListener("keydown",e=>{
  if(["ArrowUp","w","W"].includes(e.key))movePlayer(0,-1);
  if(["ArrowDown","s","S"].includes(e.key))movePlayer(0,1);
  if(["ArrowLeft","a","A"].includes(e.key))movePlayer(-1,0);
  if(["ArrowRight","d","D"].includes(e.key))movePlayer(1,0);
  if(e.key==="r"||e.key==="R")resetMaze();
  if(e.key==="s"||e.key==="S")showOverlay();
  if(e.key==="q"||e.key==="Q")overlay.style.display='none';
  if(e.key==="m"||e.key==="M")toggleMinimap();
  if(e.key==="c"||e.key==="C")toggleMode("cb");
  if(e.key==="n"||e.key==="N")toggleMode("min");
  if(e.key==="h"||e.key==="H")toggleMode("high");
});
// Initialize
resetMaze();
</script>
</body>
</html>
